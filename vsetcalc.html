<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>VECTORSET Memory Calculator</title>
    <style>
        :root {
            --background: #ffffff;
            --foreground: #020817;
            --muted: #f1f5f9;
            --muted-foreground: #64748b;
            --border: #e2e8f0;
            --primary: #0f172a;
            --primary-foreground: #ffffff;
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, "Helvetica Neue", sans-serif;
            max-width: 800px;
            margin: 0 auto;
            padding: 20px;
            line-height: 1.6;
            background: var(--background);
            color: var(--foreground);
        }

        .form-group {
            margin-bottom: 1.5rem;
        }

        label {
            display: block;
            margin-bottom: 0.5rem;
            font-weight: 500;
            font-size: 0.875rem;
            color: var(--foreground);
        }

        select, input {
            width: 100%;
            padding: 0.5rem;
            border: 1px solid var(--border);
            border-radius: 0.375rem;
            font-size: 0.875rem;
            background: var(--background);
            color: var(--foreground);
            transition: border-color 0.2s;
        }

        select:focus, input:focus {
            outline: none;
            border-color: var(--primary);
            box-shadow: 0 0 0 1px var(--primary);
        }

        .results {
            background: var(--muted);
            padding: 1.5rem;
            border-radius: 0.5rem;
            margin-top: 1.5rem;
        }

        .note {
            font-style: italic;
            color: var(--muted-foreground);
            margin-top: 1.5rem;
            font-size: 0.875rem;
        }

        button {
            background: var(--primary);
            color: var(--primary-foreground);
            padding: 0.5rem 1rem;
            border: none;
            border-radius: 0.375rem;
            font-weight: 500;
            cursor: pointer;
            transition: opacity 0.2s;
        }

        button:hover {
            opacity: 0.9;
        }

        #projectedDimContainer {
            display: none;
        }

        h1 {
            font-size: 1.875rem;
            font-weight: 600;
            margin-bottom: 2rem;
            color: var(--foreground);
        }

        .results h2 {
            margin-top: 0;
            font-size: 1.5rem;
            font-weight: 600;
        }

        .results p {
            margin: 0.5rem 0;
        }

        .results strong {
            font-weight: 500;
        }

        .command-section {
            margin-bottom: 2rem;
        }

        .command-block {
            background: var(--muted);
            padding: 1rem;
            border-radius: 0.5rem;
            margin-top: 1rem;
        }

        .checkbox-group {
            display: flex;
            align-items: center;
            gap: 0.5rem;
        }

        .checkbox-group label {
            margin-bottom: 0;
            cursor: pointer;
        }

        .checkbox-group input[type="checkbox"] {
            width: auto;
            margin: 0;
            cursor: pointer;
        }

        .columns {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 2rem;
        }

        @media (max-width: 768px) {
            .columns {
                grid-template-columns: 1fr;
            }
        }
    </style>
</head>
<body>
    <h1>Redis Vector Set - Memory Usage Calculator</h1>

    <div class="command-section">
        <h2>Redis Command</h2>
        <pre class="command-block" id="redisCommand"></pre>
        <div class="note">
            This command adds a vector to a Redis vector set with the specified parameters.
            - Replace the placeholder values with your actual vector values
            - Replace 'my_element' with your element identifier
            - Use REDUCE for dimension reduction
            - BIN flag for binary quantization
        </div>
    </div>

    <div class="form-group">
        <label for="numVectors">Number of vectors (N):</label>
        <input type="number" id="numVectors" value="1000000">
    </div>

    <div class="columns">
        <div class="column">
            <div class="form-group">
                <label for="modelSelect">Select an embedding model:</label>
                <select id="modelSelect">
                    <option value="1536">text-embedding-ada-002 (DIM 1536) (From OpenAI)</option>
                    <option value="768">text-search-babbage-001 (DIM 768) (From OpenAI)</option>
                    <option value="1024">text-search-curie-001 (DIM 1024) (From OpenAI)</option>
                    <option value="12288">text-similarity-davinci-001 (DIM 12288) (From OpenAI)</option>
                    <option value="custom">Custom (enter dimension)</option>
                </select>
            </div>

            <div class="form-group" id="customDimContainer" style="display: none;">
                <label for="customDim">Custom dimension:</label>
                <input type="number" id="customDim" value="1536">
            </div>

            <div class="form-group">
                <div class="checkbox-group">
                    <input type="checkbox" id="useProjection">
                    <label for="useProjection">Use projection?</label>
                </div>
            </div>
        </div>

        <div class="column">
            <div class="form-group" id="projectedDimContainer">
                <label for="projectedDim">Projected dimension:</label>
                <input type="number" id="projectedDim" value="256">
            </div>

            <div class="form-group">
                <label for="quantType">Quantization Type:</label>
                <select id="quantType">
                    <option value="0">FP32 (4 bytes/dim, NOQUANT)</option>
                    <option value="1" selected>Q8 (1 byte/dim + small overhead) (Default)</option>
                    <option value="2">BIN (1 bit/dim)</option>
                </select>
            </div>
        </div>
    </div>

    <button onclick="calculate()">Calculate Memory Usage</button>

    <div class="results" id="results">
        <!-- Results will be inserted here -->
    </div>

    <div class="note">
        NOTE: This includes structural overhead and (optionally) the projection matrix.
        Use with caution. Actual usage may differ.
    </div>

    <script>
        // HNSW parameters (kept constant as in C version)
        const p = 0.25;
        const M = 16;
        const M0 = 32;
        const maxThreads = 128;

        function estimateHNSWMemoryUsagePerNode(storeDim, quantType) {
            // Constants from hnsw.h
            const MAX_LEVELS = 16;
            
            // 1) Node struct base overhead
            const nodeStructOverhead = (
                4 * maxThreads +  // visited_epoch array
                4 +               // uid
                4 +               // level
                4 * MAX_LEVELS +  // num_neighbors array
                8 * MAX_LEVELS    // neighbors pointer array
            );

            // 2) Average number of levels and pointers
            const avgLevels = 1.0 + (p / (1.0 - p));
            const effectiveUpperLayers = Math.max(avgLevels - 1.0, 0.0);
            const avgPointers = M0 + effectiveUpperLayers * M;
            const pointerBytes = avgPointers * 8.0;

            // 3) Vector storage based on quantization
            let vectorBytes = 0.0;
            switch (parseInt(quantType)) {
                case 0: // FP32
                    vectorBytes = 4.0 * storeDim;
                    break;
                case 1: // Q8
                    vectorBytes = storeDim + 8.0;  // 1 byte per dim + 8 bytes for range
                    break;
                case 2: // BIN
                    vectorBytes = Math.ceil(storeDim / 8.0);
                    break;
                default:
                    vectorBytes = 4.0 * storeDim;
            }

            return Math.floor(nodeStructOverhead + pointerBytes + vectorBytes + 0.5);
        }

        function estimateHNSWMemoryUsage(N, originalDim, storeDim, quantType, useProjection) {
            // 1) Per-node usage
            const perNode = estimateHNSWMemoryUsagePerNode(storeDim, quantType);
            
            // 2) Total for all N nodes
            let total = perNode * N;

            // 3) If we keep the projection matrix in memory, add it
            if (useProjection && storeDim < originalDim) {
                const matrixBytes = originalDim * storeDim * 4;
                total += matrixBytes;
            }

            return total;
        }

        function formatBytes(bytes) {
            const mb = bytes / (1024 * 1024);
            return `${bytes.toLocaleString()} bytes (${mb.toFixed(2)} MB)`;
        }

        // UI handling functions
        document.getElementById('modelSelect').addEventListener('change', function() {
            const customDimContainer = document.getElementById('customDimContainer');
            customDimContainer.style.display = this.value === 'custom' ? 'block' : 'none';
        });

        document.getElementById('useProjection').addEventListener('change', function() {
            const projectedDimContainer = document.getElementById('projectedDimContainer');
            projectedDimContainer.style.display = this.checked ? 'block' : 'none';
        });

        function generateVsetCommand(modelDim, storeDim, useProjection, quantType) {
            let cmd = "VADD myindex";
            
            if (useProjection) {
                cmd += ` REDUCE ${storeDim}`;
            }
            
            if (quantType == 0) {  // FP32
                cmd += ` VALUES ${modelDim} <vector_values...> my_element NOQUANT`;
            } else if (quantType == 1) {  // Q8 (default)
                cmd += ` VALUES ${modelDim} <vector_values...> my_element`;
            } else {  // BIN
                cmd += ` VALUES ${modelDim} <vector_values...> my_element BIN`;
            }
            
            return cmd;
        }

        function updateCommand() {
            const modelSelect = document.getElementById('modelSelect');
            const customDim = document.getElementById('customDim');
            const modelDim = modelSelect.value === 'custom' ? 
                parseInt(customDim.value) : parseInt(modelSelect.value);
            
            const useProjection = document.getElementById('useProjection').checked;
            const storeDim = useProjection ? 
                parseInt(document.getElementById('projectedDim').value) : modelDim;
            const quantType = document.getElementById('quantType').value;

            const cmd = generateVsetCommand(modelDim, storeDim, useProjection, quantType);
            document.getElementById('redisCommand').textContent = cmd;
        }

        // Add event listeners to update command on any change
        document.querySelectorAll('select, input').forEach(element => {
            element.addEventListener('change', updateCommand);
        });

        function calculate() {
            // Get input values
            const modelSelect = document.getElementById('modelSelect');
            const customDim = document.getElementById('customDim');
            const modelDim = modelSelect.value === 'custom' ? 
                parseInt(customDim.value) : parseInt(modelSelect.value);
            
            const N = parseInt(document.getElementById('numVectors').value);
            const useProjection = document.getElementById('useProjection').checked;
            const storeDim = useProjection ? 
                parseInt(document.getElementById('projectedDim').value) : modelDim;
            const quantType = document.getElementById('quantType').value;

            // Calculate
            const rawVectorBytesPerVec = 4 * modelDim;
            const totalRawBytes = rawVectorBytesPerVec * N;
            const estimateBytes = estimateHNSWMemoryUsage(N, modelDim, storeDim, quantType, useProjection);
            const expansionFactor = estimateBytes / totalRawBytes;

            // Display results
            const results = document.getElementById('results');
            results.innerHTML = `
                <h2>Memory Usage Results</h2>
                <p><strong>Number of vectors:</strong> ${N.toLocaleString()}</p>
                <p><strong>Model:</strong> ${modelSelect.options[modelSelect.selectedIndex].text}</p>
                <p><strong>Raw vector data:</strong> ${formatBytes(totalRawBytes)}</p>
                <p><strong>Estimated total HNSW usage:</strong> ${formatBytes(estimateBytes)}</p>
                <p><strong>Expansion factor vs. raw:</strong> ${expansionFactor.toFixed(2)}x</p>
            `;
        }

        // Initial command update
        updateCommand();
    </script>
</body>
</html> 